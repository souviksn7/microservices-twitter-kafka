#Used to bind external properties into an application at runtime
twitter-to-kafka-service:
  twitter-keywords:
    - Java
    - Microservices
    - Spring
    - Elasticsearch
    - Kafka
  welcome-message: Welcome to twitter-to-kafka service
  enable-v2-tweets: false
  enable-mock-tweets: true
  mock-min-tweet-length: 5
  mock-max-tweet-length: 15
  mock-sleep-ms: 1000
  twitter-v2-base-url: https://api.x.com/2/tweets/search/stream?tweet.fields=created_at&expansions=author_id
  twitter-v2-rules-base-url: https://api.x.com/2/tweets/search/stream/rules
  twitter-v2-bearer-token: AAAAAAAAAAAAAAAAAAAAAJqKwgEAAAAAZ2d7qJ67zaVwBWZP%2ByodJ%2FjKK1U%3DBlmgqpo4SeIajRO0Ow6Rrl0D1fUUYfgtaSTLxDjLsTmVnwWlZR

retry-config:
  initial-interval-ms: 1000
  max-interval-ms: 10000
  multiplier: 2.0
  maxAttempts: 3
  sleep-time-ms: 2000

kafka-config:
  bootstrap-servers: localhost:19092, localhost:29092, localhost:39092
  schema-registry-url-key: schema.registry.url
  schema-registry-url: http://localhost:8081
  topic-name: twitter-topic
  topic-names-to-create:
    - twitter-topic
  num-of-partitions: 3 #When the partition count for a Kafka topic is set to 3, it means that the topic is divided into three partitions, which are independent, distributed segments of the topic's data. Each partition acts as an append-only log and stores a subset of the messages for the topic.
  replication-factor: 3

kafka-producer-config:
  key-serializer-class: org.apache.kafka.common.serialization.LongSerializer #key serializer class will be long because we will use a long variable for key
  value-serializer-class: io.confluent.kafka.serializers.KafkaAvroSerializer #For value type, we said KafkaAvroSerializer which is class in confluent library
  compression-type: snappy #For compression, we choose snappy. Snappy is compression library from Google. It's faster than other options
  acks: all #For acknowledge, we choose all because we want to get acknowledgement from all replicas to be more resilient. We can set it to 1 or 0. If it's set to one, it will wait for the broker that gets request from produces client. And if it's set to zero, it will not wait and return immediately without acknowledgement.
  batch-size: 16384 #batch-size = Tune for higher throughput
  batch-size-boost-factor: 100 #boost factor is to try different values and see if it performs better or not. It's set to 100 times of the default value to enable more batching and to get high throughput.
  linger-ms: 5 #This adds a 5ms delay on producer client in case of light load to wait before sending the records to kafka
  request-timeout-ms: 60000 #Here we say that after 60 seconds, if no acknowledgement comes, producer will throw timeout error.
  retry-count: 5 #It will 5 times in case of error.